<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Gemmit – Chat Editor</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap" rel="stylesheet">
  <style>
    :root {
      --brand-purple: #6e6bff;
      --brand-pink: #ff6bcb;
      --surface-100: #0f0f0f;
      --surface-200: #181818;
      --surface-300: #1f1f1f;
      --surface-border: #2c2c2c;
      --text: #ffffff;
      --text-muted: #b5b5b5;
      --radius: 0.75rem;
    }
    * { margin:0; padding:0; box-sizing:border-box; }
    html, body { height:100%; }
    body { font-family:'Inter',sans-serif; color:var(--text); background:var(--surface-100); display:flex; flex-direction:column; }
    button { cursor:pointer; }
    .topbar { height:48px; background:var(--surface-200); display:flex; align-items:center; justify-content:space-between; padding:0 1rem; border-bottom:1px solid var(--surface-border); }
    .topbar-left, .topbar-right { display:flex; align-items:center; gap:.75rem; }
    .btn-sm { font-size:.75rem; padding:.25rem .75rem; border:1px solid var(--surface-border); background:var(--surface-300); color:var(--text); border-radius:var(--radius); }
    .btn-primary { background:linear-gradient(90deg,var(--brand-purple),var(--brand-pink)); border:none; color:#fff; }
    .workspace { flex:1; display:flex; min-height:0; }
    .panel-chat { width:360px; background:var(--surface-200); border-right:1px solid var(--surface-border); display:flex; flex-direction:column; }
    .chat-header { padding:.75rem; border-bottom:1px solid var(--surface-border); display:flex; align-items:center; justify-content:space-between; }
    .conversation-list { max-height:150px; overflow-y:auto; border-bottom:1px solid var(--surface-border); }
    .conversation-item { padding:.5rem .75rem; cursor:pointer; border-bottom:1px solid var(--surface-border); transition:background .2s; }
    .conversation-item:hover { background:var(--surface-300); }
    .conversation-item.active { background:var(--brand-purple); }
    .conversation-preview { font-size:.8rem; color:var(--text-muted); margin-top:.25rem; }
    .conversation-meta { font-size:.7rem; color:var(--text-muted); margin-top:.25rem; }
    .panel-preview { flex:1; background:var(--surface-100); display:flex; flex-direction:column; }
    .chat-scroll { flex:1; overflow-y:auto; padding:1rem; display:flex; flex-direction:column; gap:1rem; }
    .chat-bubble { border-radius:var(--radius); padding:1rem; font-size:.9rem; line-height:1.4; white-space:pre-wrap; }
    .bubble-user { background:var(--surface-300); align-self:flex-end; text-align:right; }
    .bubble-ai { border-left:3px solid var(--surface-border); color:var(--text-muted); padding-left:.75rem; }
    .chat-input { border-top:1px solid var(--surface-border); padding:.75rem; display:flex; flex-direction:column; gap:.5rem; }
    .chat-input input, .chat-input textarea { width:100%; padding:.5rem; background:var(--surface-300); border:1px solid var(--surface-border); border-radius:var(--radius); color:var(--text); resize:none; outline:none; }
    .chat-input .row-actions { display:flex; justify-content:space-between; gap:.5rem; }
    .btn-cancel { background:var(--surface-300); border:1px solid #ff6b6b; color:#ff6b6b; }
    .btn-cancel:disabled { opacity:0.5; cursor:not-allowed; }
    .btn-nav { width:2rem; height:2rem; display:flex; align-items:center; justify-content:center; font-weight:bold; }
    .btn-nav:disabled { opacity:0.3; cursor:not-allowed; }
    .loading-indicator { display:none; align-items:center; gap:.5rem; color:var(--text-muted); font-size:.8rem; }
    .loading-indicator.active { display:flex; }
    .spinner { width:12px; height:12px; border:2px solid var(--surface-border); border-top:2px solid var(--brand-purple); border-radius:50%; animation:spin 1s linear infinite; }
    @keyframes spin { 0% { transform:rotate(0deg); } 100% { transform:rotate(360deg); } }
    .preview-header { padding:.75rem; background:var(--surface-200); border-bottom:1px solid var(--surface-border); display:flex; align-items:center; gap:.5rem; }
    .preview-header input { width:5rem; background:var(--surface-300); border:1px solid var(--surface-border); border-radius:var(--radius); color:var(--text); padding:.25rem .5rem; }
    .preview-frame { flex:1; border:none; width:100%; height:100%; }
    .preview-error { color:var(--text-muted); text-align:center; margin-top:2rem; }
    .status-message { padding:.5rem; background:var(--surface-300); border-radius:var(--radius); margin-bottom:.5rem; font-size:.8rem; color:var(--text-muted); }
  </style>
</head>
<body>
  <header class="topbar">
    <div class="topbar-left"><span>Gemmit Builder</span></div>
    <div class="topbar-right">
      <button class="btn-sm btn-primary" id="start-frontend">Start Frontend</button>
      <button class="btn-sm btn-cancel" id="stop-frontend">Stop Server</button>
    </div>
  </header>

  <div class="workspace">
    <aside class="panel-chat">
      <div class="chat-header">
        <span>Conversations</span>
        <div>
          <button class="btn-sm" id="refresh-conversations" title="Refresh">↻</button>
          <button class="btn-sm" id="new-conversation">New</button>
        </div>
      </div>
      <div class="conversation-list" id="conversation-list"></div>
      <div class="chat-scroll" id="chat-scroll"></div>
      <div class="chat-input">
        <input type="text" id="output-dir" placeholder="Output directory (optional)" />
        <input type="number" id="preview-port" placeholder="Port" />
        <textarea id="prompt-input" rows="2" placeholder="Ask Gemmit..."></textarea>
        <div class="loading-indicator" id="loading-indicator">
          <div class="spinner"></div>
          <span>AI is thinking...</span>
        </div>
        <div class="row-actions">
          <button class="btn-sm" id="send-btn">Send</button>
          <button class="btn-sm btn-cancel" id="cancel-btn" disabled>Cancel</button>
        </div>
      </div>
    </aside>

    <section class="panel-preview">
      <div class="preview-header">
        <button class="btn-sm btn-nav" id="back-btn" title="Go Back">←</button>
        <button class="btn-sm btn-nav" id="forward-btn" title="Go Forward">→</button>
        <label>Preview Port:</label>
        <input type="number" id="preview-port-display" disabled />
        <button class="btn-sm btn-primary" id="reload-preview">Reload</button>
        <button class="btn-sm" id="hard-refresh">Hard Refresh</button>
        <button class="btn-sm" id="debug-status">Debug</button>
        <button class="btn-sm" id="test-html">Test HTML</button>
      </div>
      <iframe id="preview-frame" class="preview-frame" 
              sandbox="allow-same-origin allow-scripts allow-forms allow-popups allow-modals"
              loading="eager"></iframe>
      <div id="preview-error" class="preview-error"></div>
    </section>
  </div>

  <script>
    // Config from server
    const cfg = window.APP_CONFIG || {};

    // Ensure single conversationId
    let conversationId = cfg.conversationId || 'conv-' + Date.now();

    // WebSocket
    const wsUrl = cfg.wsUrl || 'ws://localhost:8000';
    const socket = new WebSocket(wsUrl);
    socket.onmessage = e => {
      const msg = JSON.parse(e.data);
      if (msg.type === 'stream') appendBot(msg.data);
      if (msg.type === 'result') {
        console.log('Result:', msg);
        setProcessingState(false);
      }
      if (msg.type === 'status') {
        if (msg.status === 'running') {
          setProcessingState(true);
        } else if (msg.status === 'complete') {
          setProcessingState(false);
        }
      }
      if (msg.type === 'frontend_result') {
        appendStatus(msg.message);
        if (msg.success) {
          // Reload preview after a longer delay to let server fully start
          appendStatus('Waiting for server to be ready...');
          setTimeout(() => {
            loadPreview(false); // Don't cache bust when server starts
            appendStatus('Preview reloaded');
          }, 2000);
        }
      }
      if (msg.type === 'cancel_result') {
        appendStatus(msg.message);
        setProcessingState(false);
      }
      if (msg.type === 'status_info') {
        appendStatus(`Debug: Active processes: ${msg.active_processes.length}, Active tasks: ${msg.active_tasks.length}, Frontend processes: ${msg.frontend_processes.length}`);
      }
      if (msg.type === 'frontend_result' && msg.message.includes('stopped')) {
        appendStatus(msg.message);
      }
      if (msg.type === 'conversation_list') {
        updateConversationList(msg.conversations);
      }
      if (msg.type === 'conversation_loaded') {
        loadConversation(msg.conversationId, msg.messages);
      }
    };
    socket.onclose = () => console.log('Socket closed');

    // Elements
    const chatScroll = document.getElementById('chat-scroll');
    const promptInput = document.getElementById('prompt-input');
    const sendBtn = document.getElementById('send-btn');
    const cancelBtn = document.getElementById('cancel-btn');
    const loadingIndicator = document.getElementById('loading-indicator');
    const outputDirInput = document.getElementById('output-dir');
    const portInput = document.getElementById('preview-port');
    const portDisplay = document.getElementById('preview-port-display');
    const reloadBtn = document.getElementById('reload-preview');
    const hardRefreshBtn = document.getElementById('hard-refresh');
    const debugBtn = document.getElementById('debug-status');
    const testHtmlBtn = document.getElementById('test-html');
    const backBtn = document.getElementById('back-btn');
    const forwardBtn = document.getElementById('forward-btn');
    const previewFrame = document.getElementById('preview-frame');
    const startFrontendBtn = document.getElementById('start-frontend');
    const stopFrontendBtn = document.getElementById('stop-frontend');
    const newConversationBtn = document.getElementById('new-conversation');
    const refreshConversationsBtn = document.getElementById('refresh-conversations');
    const conversationList = document.getElementById('conversation-list');
    
    // State tracking
    let isProcessing = false;
    let currentConversationId = conversationId;
    let conversations = {};

    // --- NEW: Preload prompt from URL query parameter ---
    const urlParams = new URLSearchParams(window.location.search);
    const initialPrompt = urlParams.get('prompt');
    if (initialPrompt) {
      // Decode & set the textarea value
      promptInput.value = decodeURIComponent(initialPrompt);
    }
    // --- END NEW ---

    // Initialize inputs
    portInput.value = cfg.previewPort || 5002;
    outputDirInput.value = cfg.generationsDir || '';
    function loadPreview(forceCacheBust = false) {
      const p = portInput.value;
      portDisplay.value = p;
      
      let url = `http://localhost:${p}`;
      
      // Only add cache-busting when explicitly requested (for reloads)
      if (forceCacheBust) {
        const timestamp = Date.now();
        url += `?_cb=${timestamp}`;
      }
      
      previewFrame.src = url;
      
      // Add error handling for iframe load
      previewFrame.onload = () => {
        console.log(`Preview loaded: ${url}`);
      };
      
      previewFrame.onerror = (e) => {
        console.error(`Preview load error: ${e}`);
        appendStatus(`Failed to load preview from ${url}`);
      };
    }
    reloadBtn.addEventListener('click', () => loadPreview(true)); // Force cache bust on reload
    hardRefreshBtn.addEventListener('click', () => {
      // Force a complete reload by clearing the src first
      previewFrame.src = 'about:blank';
      setTimeout(() => loadPreview(true), 100); // Force cache bust on hard refresh
    });
    debugBtn.addEventListener('click', () => {
      socket.send(JSON.stringify({
        command: 'status'
      }));
    });
    
    // Test HTML serving
    testHtmlBtn.addEventListener('click', async () => {
      const port = portInput.value || 5002;
      const testUrls = [
        `http://localhost:${port}/`,
        `http://localhost:${port}/index.html`
      ];
      
      appendStatus('Testing HTML serving...');
      
      for (const url of testUrls) {
        try {
          const response = await fetch(url);
          const contentType = response.headers.get('content-type') || 'unknown';
          const text = await response.text();
          
          appendStatus(`${url} -> Status: ${response.status}, Type: ${contentType}`);
          
          if (text.trim().startsWith('<!DOCTYPE') || text.trim().startsWith('<html')) {
            appendStatus(`✅ Valid HTML content (${text.length} chars)`);
          } else {
            appendStatus(`❌ Not HTML: ${text.substring(0, 100)}...`);
          }
        } catch (e) {
          appendStatus(`❌ ${url} -> Error: ${e.message}`);
        }
      }
    });
    
    // Navigation buttons with error handling
    backBtn.addEventListener('click', () => {
      try {
        if (previewFrame.contentWindow) {
          previewFrame.contentWindow.history.back();
        }
      } catch (e) {
        // Cross-origin restrictions - try alternative approach
        console.log('Cannot access iframe history due to cross-origin restrictions');
        appendStatus('Cannot navigate back - cross-origin restrictions');
      }
    });
    
    forwardBtn.addEventListener('click', () => {
      try {
        if (previewFrame.contentWindow) {
          previewFrame.contentWindow.history.forward();
        }
      } catch (e) {
        // Cross-origin restrictions - try alternative approach
        console.log('Cannot access iframe history due to cross-origin restrictions');
        appendStatus('Cannot navigate forward - cross-origin restrictions');
      }
    });
    
    loadPreview();
    
    // Conversation management functions
    function updateConversationList(conversationData) {
      conversationList.innerHTML = '';
      conversations = {};
      
      conversationData.forEach(conv => {
        conversations[conv.id] = conv;
        
        const item = document.createElement('div');
        item.className = 'conversation-item';
        if (conv.id === currentConversationId) {
          item.classList.add('active');
        }
        
        item.innerHTML = `
          <div>${conv.id.substring(0, 8)}...</div>
          <div class="conversation-preview">${conv.preview}</div>
          <div class="conversation-meta">${conv.messageCount} messages</div>
        `;
        
        item.addEventListener('click', () => {
          selectConversation(conv.id);
        });
        
        conversationList.appendChild(item);
      });
    }
    
    function selectConversation(conversationId) {
      // Update active conversation
      document.querySelectorAll('.conversation-item').forEach(item => {
        item.classList.remove('active');
      });
      
      const selectedItem = Array.from(conversationList.children).find(item => 
        item.textContent.includes(conversationId.substring(0, 8))
      );
      if (selectedItem) {
        selectedItem.classList.add('active');
      }
      
      // Load the conversation
      socket.send(JSON.stringify({
        command: 'load-conversation',
        conversationId: conversationId
      }));
    }
    
    function loadConversation(conversationId, messages) {
      currentConversationId = conversationId;
      
      // Clear current chat
      chatScroll.innerHTML = '';
      
      // Load messages
      messages.forEach(message => {
        if (message.startsWith('User: ')) {
          appendUser(message.substring(6));
        } else if (message.startsWith('Model: ')) {
          appendBot(message.substring(7));
        }
      });
      
      appendStatus(`Loaded conversation ${conversationId.substring(0, 8)}...`);
    }
    
    function createNewConversation() {
      currentConversationId = 'conv-' + Date.now();
      chatScroll.innerHTML = '';
      
      // Update UI
      document.querySelectorAll('.conversation-item').forEach(item => {
        item.classList.remove('active');
      });
      
      appendStatus('Started new conversation');
    }
    
    // Load conversation list on startup
    socket.onopen = () => {
      console.log('Socket open');
      socket.send(JSON.stringify({
        command: 'list-conversations'
      }));
    };

    // Append functions
    function appendUser(text) {
      const d = document.createElement('div');
      d.className = 'chat-bubble bubble-user';
      d.textContent = text;
      chatScroll.append(d);
      d.scrollIntoView();
    }
    function appendBot(text) {
      let last = chatScroll.lastElementChild;
      if (!last || !last.classList.contains('bubble-ai')) {
        last = document.createElement('div');
        last.className = 'chat-bubble bubble-ai';
        chatScroll.append(last);
      }
      last.textContent += text;
      last.scrollIntoView();
    }
    function appendStatus(text) {
      const d = document.createElement('div');
      d.className = 'status-message';
      d.textContent = text;
      chatScroll.append(d);
      d.scrollIntoView();
    }
    
    // State management
    function setProcessingState(processing) {
      isProcessing = processing;
      sendBtn.disabled = processing;
      cancelBtn.disabled = !processing;
      if (processing) {
        loadingIndicator.classList.add('active');
      } else {
        loadingIndicator.classList.remove('active');
      }
    }

    // Send handler
    sendBtn.addEventListener('click', () => {
      if (isProcessing) return;
      const prompt = promptInput.value.trim();
      if (!prompt) return;
      
      appendUser(prompt);
      setProcessingState(true);
      
      const payload = {
        prompt,
        conversationId,
        previewPort: portInput.value,
        context: `Spin up frontend on port ${portInput.value} in background.`
      };
      if (outputDirInput.value.trim()) {
        payload.generationsDir = outputDirInput.value.trim();
      }
      // Update the payload to use current conversation ID
      payload.conversationId = currentConversationId;
      
      socket.send(JSON.stringify(payload));
      promptInput.value = '';
    });
    
    // Cancel handler
    cancelBtn.addEventListener('click', () => {
      if (!isProcessing) return;
      socket.send(JSON.stringify({
        command: 'cancel',
        conversationId: currentConversationId
      }));
    });
    
    // New conversation handler
    newConversationBtn.addEventListener('click', () => {
      createNewConversation();
    });
    
    // Refresh conversations handler
    refreshConversationsBtn.addEventListener('click', () => {
      socket.send(JSON.stringify({
        command: 'list-conversations'
      }));
    });

    // Start Frontend command
    startFrontendBtn.addEventListener('click', () => {
      const port = portInput.value || 5002;
      appendStatus(`Starting frontend server on port ${port}...`);
      socket.send(JSON.stringify({
        command: 'start-frontend',
        port: port,
        conversationId
      }));
    });
    
    // Stop Frontend command
    stopFrontendBtn.addEventListener('click', () => {
      const port = portInput.value || 5002;
      appendStatus(`Stopping frontend server on port ${port}...`);
      socket.send(JSON.stringify({
        command: 'stop-frontend',
        port: port,
        conversationId
      }));
    });

    // Enter to send
    promptInput.addEventListener('keydown', e => {
      if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        if (!isProcessing) {
          sendBtn.click();
        }
      }
    });
  </script>
</body>
</html>

